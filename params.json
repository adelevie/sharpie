{"name":"Sharpie","tagline":"Static site generation with a familiar API","body":"[![Gem Version](https://badge.fury.io/rb/sharpie.png)](http://badge.fury.io/rb/sharpie)\r\n\r\n[![Code Climate](https://codeclimate.com/github/adelevie/sharpie.png)](https://codeclimate.com/github/adelevie/sharpie)\r\n\r\n[![Build Status](https://travis-ci.org/adelevie/sharpie.png)](https://travis-ci.org/adelevie/sharpie)\r\n\r\n\r\n# Sharpie\r\n\r\nQuick and easy static site generation with a familiar API.\r\n\r\n## Usage\r\n\r\n```ruby\r\nclass App < Sharpie::Base\r\n  \r\n  get \"/\" do\r\n    \"Hello, world.\"\r\n  end\r\n\r\n  # get posts from ActiveRecord or elsewhere\r\n  def self.posts\r\n    Post.all\r\n  end\r\n\r\n  posts.each do |post|\r\n    get \"/posts/#{post.id}\" do\r\n      erb :post\r\n    end\r\n\r\n    get \"/posts/#{post.id}.json\" do\r\n      post.to_json\r\n    end\r\n  end\r\n\r\nend\r\n\r\n\r\nApp.build!(\"_site\")\r\n```\r\n\r\nOr use with an existing Sinatra application:\r\n\r\n```ruby\r\nclass App < Sinatra::Base\r\n  register Sinatra::AdvancedRoutes # this is required\r\n\r\n  def self.posts\r\n    Post.all\r\n  end\r\n\r\n  posts.each do |post|\r\n    get \"/posts/#{post['id']}.json\" do\r\n      post.to_json\r\n    end\r\n  end\r\n\r\n  get \"/\" do\r\n    erb :index\r\n  end\r\nend\r\n\r\nbuilder = Sharpie::Builder.new(App)\r\nbuilder.build!(\"_site\")\r\n```\r\n\r\n`Sharpie::Base` subclasses from `Sinatra::Base`.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'sharpie'\r\n```\r\n\r\nAnd then execute:\r\n\r\n```sh\r\n$ bundle\r\n```\r\n\r\nOr install it yourself as:\r\n\r\n```sh\r\n$ gem install sharpie\r\n```\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\n## Why \r\n\r\nSinatra routes make web app and API creation dead-simple. The syntax is straightforward and allows for your site to feel more like Ruby and less like a bloated framework. There's also no reason why this powerful API should be limited to dynamic web applications. Sinatra routes simply describe a path and a response. Whether the response is evaluated ahead of time or on-the-fly should not matter.\r\n\r\n### Why not Jekyll?\r\n\r\nJekyll is great for blogs and other types of sites where content is \"hand created.\" That is, a human creates a file in a folder and writes some Markdown. Sharpie is more geared towards use-cases where the original content is already in a machine-readable format. For example, if you have a database whose contents you want to expose via REST API. You also don't want to maintain a server and you don't want to worry about scaling. With Sharpie, you can write such an API with very few (yet straightforward) lines of code.\r\n\r\n### Fork\r\n\r\nThis software is mostly a fork of the [sinatra-static](https://github.com/paulasmuth/sinatra-static) gem by [Paul Asmuth](https://twitter.com/paulasmuth). Paul's code is very well-written. I'd rather copy and attribute it than re-invent a well-made wheel. I'm focusing on building an interface that suits my needs. More specifically, I want Sharpie to be part of a toolchain for rapidly developing static file-backed REST APIs.\r\n\r\n# License\r\n\r\nThis software, which is a fork of MIT-licensed software, is also MIT-licensed. See `LICENSE.txt`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}